Iot alchemy+++++++++++++++++++++++++++++++++++
Estructura de Archivos-----------------------
    |--cli.py
    |--config.json
    |--device.py
    |--gen_qr.py
    |--iot.txt
    |--main.py
    |--manager.py
    |--templates_loader.py
    |--utils.py
    |--scripts/
        |--modificar.ps1
        |--reclamar.ps1
    |--templates/
        |--camara-seg_auto.json
        |--luces_auto.json
        |--persiana_auto.json
        |--puerta_auto.json
        |--regador_auto.json
        |--sensor_co2.json
        |--sensor_humo.json
        |--sensor_luz.json
        |--sensor_mov.json
        |--sensor_ruido.json
        |--sensor_smart-plug.json
        |--sensor_temp.json
        |--vent_auto.json

Contenido de Archivos-----------------------

cli.py----------------------------------------
# cli.py
import time
from templates_loader import cargar_plantillas
from manager import DevicesManager
from gen_qr import generar_qr_reclamo
from utils import reclamar_dispositivo, modificar_dispositivo, listar_dispositivos_backend

def show_menu():
    print("\n=== IoT Alchemy CLI ===")
    print("1) Listar plantillas")
    print("2) Crear dispositivo desde plantilla")
    print("3) Listar dispositivos activos")
    print("4) Iniciar simulaci√≥n de un dispositivo")
    print("5) Detener simulaci√≥n de un dispositivo")
    print("6) Modificar par√°metros de un dispositivo (en vivo-inyeccion de errores)")
    print("7) Iniciar simulaci√≥n de todos")
    print("8) Detener simulaci√≥n de todos")
    print("9) Generar QR de dispositivo (Abre Navegador)")
    print("++++++++++++++ Simulaciones de Front-End ++++++++++++++")
    print("10) Reclamar dispositivo v√≠a HTTP (PowerShell y cURL)")
    print("11) Modificar datos v√≠a HTTP (PowerShell y cURL)")
    print("0) Salir")

def iniciar_cli():
    templates = cargar_plantillas()
    manager = DevicesManager()

    while True:
        show_menu()
        opt = input("Opci√≥n: ").strip()
        if opt == "1":
            if not templates:
                print("No hay plantillas en /templates")
            else:
                print("Plantillas:")
                for name in templates:
                    print(" -", name)

        elif opt == "2":
            print("Seleccione plantilla:")
            keys = list(templates.keys())
            if not keys:
                print("No hay plantillas.")
                continue
            for i, k in enumerate(keys, 1):
                print(f"{i}) {k}")
            sel = input("N√∫mero: ").strip()
            try:
                idx = int(sel) - 1
                tpl = templates[keys[idx]]
            except Exception:
                print("Selecci√≥n inv√°lida.")
                continue

            serial_custom = input("Serial personalizado (ENTER para aleatorio): ").strip() or None
            cnt = input("¬øCu√°ntos dispositivos crear? (1): ").strip() or "1"
            try:
                cnt = int(cnt)
            except Exception:
                cnt = 1

            created = manager.create_from_template(tpl, count=cnt, serial_custom=serial_custom)
            for d in created:
                print(f"Creado: {d.serial} (intervalo: {d.interval}s)")

        elif opt == "3":
            devs = manager.list_devices()
            if not devs:
                print("No hay dispositivos creados.")
            else:
                for d in devs:
                    print(f"- {d.serial} | apagado:{d.apagado} | intervalo:{d.interval}s | params:{d.parametros}")

        elif opt == "4":
            s = input("Serial del dispositivo a iniciar: ").strip()
            d = manager.get(s)
            if not d:
                print("No encontrado.")
            else:
                d.start()
                print("Simulaci√≥n iniciada.")

        elif opt == "5":
            s = input("Serial del dispositivo a detener: ").strip()
            d = manager.get(s)
            if not d:
                print("No encontrado.")
            else:
                d.stop()
                print("Simulaci√≥n detenida.")

        elif opt == "6":
            s = input("Serial del dispositivo: ").strip()
            d = manager.get(s)
            if not d:
                print("No encontrado.")
            else:
                print("Par√°metros actuales:", d.parametros)
                key = input("Par√°metro a modificar: ").strip()
                if key not in d.parametros:
                    print("Par√°metro no existe.")
                else:
                    val = input("Nuevo valor: ").strip()
                    if val.lower() in ("true", "false"):
                        newv = val.lower() == "true"
                    else:
                        try:
                            if "." in val:
                                newv = float(val)
                            else:
                                newv = int(val)
                        except Exception:
                            newv = val
                    d.set_parametro(key, newv)
                    print("Par√°metro actualizado.")

        elif opt == "7":
            manager.start_all()
            print("Todas las simulaciones iniciadas.")

        elif opt == "8":
            manager.stop_all()
            print("Todas las simulaciones detenidas.")

        elif opt == "9":
            serial = input("Ingrese el serial del dispositivo: ").strip()
            generar_qr_reclamo(serial, templates)
        
        elif opt == "10":
            serial = input("Ingrese el serial del dispositivo: ")
            reclamar_dispositivo(serial, list(templates.values()))

        elif opt == "11":
            modificar_dispositivo()

        elif opt == "0":
            print("Saliendo...")
            manager.stop_all()
            break
        else:
            print("Opci√≥n inv√°lida.")
        time.sleep(0.2)
config.json----------------------------------------
{
  "mqtt_host": "localhost",
  "mqtt_port": 1883,
  "mqtt_topic_estado": "dispositivos/estado",
  "backend_url": "http://localhost:5000",
  "poll_config_interval": 3
}

device.py----------------------------------------
# device.py
import json
import os
import time
import threading
import random
import requests
import datetime
from paho.mqtt import publish
from utils import clamp

CONFIG_PATH = os.path.join(os.path.dirname(__file__), "config.json")
with open(CONFIG_PATH, "r", encoding="utf-8") as f:
    CONFIG = json.load(f)

# Mapa de equivalencias espa√±ol -> ingl√©s
DAY_MAP = {
    "lunes": "monday",
    "martes": "tuesday",
    "miercoles": "wednesday",
    "mi√©rcoles": "wednesday",
    "jueves": "thursday",
    "viernes": "friday",
    "sabado": "saturday",
    "s√°bado": "saturday",
    "domingo": "sunday",
}

class DeviceSimulator:
    """
    Publica SOLO por MQTT:
      { "serial_number", "estado", "parametros" }

    No env√≠a nada por HTTP. Opcionalmente LEE (GET) del backend
    para aplicar configuraciones:
      configuracion.intervalo_envio -> self.interval
      configuracion.encendido (True/False) -> self.apagado
      configuracion.modo ("manual"/"horario") -> define comportamiento
    """

    def __init__(
        self,
        serial,
        parametros_rules,
        mqtt_topic=None,
        interval=5,
        mqtt_host=None,
        backend_url=None,
        poll_config_interval=None
    ):
        self.serial = serial
        self.param_rules = parametros_rules or {}
        self.mqtt_topic = mqtt_topic or CONFIG.get("mqtt_topic_estado", "dispositivos/estado")
        self.mqtt_host = mqtt_host or CONFIG.get("mqtt_host", "localhost")
        self.backend_url = backend_url or CONFIG.get("backend_url")
        self.interval = max(1, int(interval))

        # Flags e hilos
        self.running = False
        self._thread = None
        self._cfg_thread = None

        # Estado/params
        self.apagado = False  # apagado=True -> estado="inactivo"
        self.parametros = {}
        for k, rule in self.param_rules.items():
            mn = rule.get("min", 0)
            mx = rule.get("max", 1)
            t = rule.get("tipo")
            if t in ("float", "double"):
                self.parametros[k] = round(random.uniform(mn, mx), 2)
            elif t == "int":
                self.parametros[k] = random.randint(int(mn), int(mx))
            elif t == "boolean":
                self.parametros[k] = random.choice([True, False])
            else:
                self.parametros[k] = rule.get("default")

        # Config remota (solo lectura)
        self.poll_config_interval = max(1, int(poll_config_interval or CONFIG.get("poll_config_interval", 3)))
        self._device_id = None  # cache para GET /dispositivos/<id>
        self.inyecciones = {k: False for k in self.param_rules}

        # √öltimo encendido sincronizado al backend
        self._last_encendido_sync = None

    # ----------- Simulaci√≥n -----------
    def _step(self):
        for k, rule in self.param_rules.items():
            if self.inyecciones.get(k, False):
                continue

            t = rule.get("tipo")
            if t in ("float", "double"):
                var = rule.get("variacion", (rule.get("max", 1) - rule.get("min", 0)) * 0.05)
                cur = float(self.parametros.get(k, 0))
                nuevo = clamp(cur + random.uniform(-var, var), rule.get("min", cur), rule.get("max", cur))
                self.parametros[k] = round(nuevo, 3)
            elif t == "int":
                var = rule.get("variacion", 1)
                cur = int(self.parametros.get(k, 0))
                nuevo = int(clamp(cur + random.randint(-var, var), rule.get("min", cur), rule.get("max", cur)))
                self.parametros[k] = nuevo
            elif t == "boolean":
                prob = rule.get("prob_flip", 0.01)
                if random.random() < prob:
                    self.parametros[k] = not bool(self.parametros.get(k, False))

    def _estado_str(self):
        return "inactivo" if self.apagado else "activo"

    def build_mqtt_payload(self):
        return {
            "serial_number": self.serial,
            "estado": self._estado_str(),
            "parametros": self.parametros
        }

    def publish_estado(self):
        payload = self.build_mqtt_payload()
        try:
            publish.single(self.mqtt_topic, json.dumps(payload), hostname=self.mqtt_host)
        except Exception as e:
            print("[MQTT ERROR]", e)

    def _run(self):
        while self.running:
            if not self.apagado:
                self._step()
                self.publish_estado()
            else:
                self.publish_estado()
            time.sleep(self.interval)

    # ----------- Config remota (solo lectura HTTP GET) -----------
    def _ensure_device_id(self):
        if not self.backend_url or self._device_id is not None:
            return
        try:
            r = requests.get(f"{self.backend_url}/dispositivos", timeout=5)
            if r.status_code == 200:
                lista = r.json()
                match = next((d for d in lista if d.get("serial_number") == self.serial), None)
                if match:
                    self._device_id = match["id"]
        except Exception as e:
            print(f"[CFG] Error buscando ID para {self.serial}: {e}")

    def _sync_encendido_to_backend(self, cfg):
        """Sincroniza encendido (y estado) al backend solo si cambi√≥."""
        if not (self.backend_url and self._device_id is not None):
            return

        new_val = bool(cfg.get("encendido"))
        if self._last_encendido_sync is not None and self._last_encendido_sync == new_val:
            return  # no hay cambios

        # üî∏ Enviar estado expl√≠cito si estamos en modo horario
        payload = {"configuracion": cfg, "encendido": new_val}
        modo = (cfg.get("modo") or "").lower()
        if modo == "horario":
            payload["estado"] = "activo" if new_val else "inactivo"

        try:
            resp = requests.put(
                f"{self.backend_url}/dispositivos/{self._device_id}",
                json=payload,
                timeout=5
            )
            if resp.status_code in (200, 204):
                self._last_encendido_sync = new_val
        except Exception as e:
            print(f"[CFG] Error sincronizando estado con backend: {e}")


    def _aplicar_config(self, cfg):
        # Si no hay modo ‚Üí dispositivo no reclamado todav√≠a
        modo = cfg.get("modo")
        if not modo:
            print(f"[CFG] {self.serial} a√∫n no reclamado, ignorando configuraci√≥n")
            return

        if modo == "manual":
            # En manual: encendido manda, estado escucha
            encendido = cfg.get("encendido", True)
            self.apagado = not bool(encendido)

        elif modo == "horario":
            # En horario: estado manda, encendido escucha
            ahora = datetime.datetime.now()
            dia_actual = ahora.strftime("%A").lower()

            activo = False
            for h in cfg.get("horarios", []):
                dias_cfg = [d.lower() for d in h.get("dias", ["todos"])]
                dias_norm = []
                for d in dias_cfg:
                    if d in DAY_MAP:
                        dias_norm.append(DAY_MAP[d])
                    else:
                        dias_norm.append(d)

                if "todos" in dias_norm or "all" in dias_norm or dia_actual in dias_norm:
                    try:
                        start_str = h.get("inicio") or h.get("start")
                        end_str   = h.get("fin")    or h.get("end")
                        if not (start_str and end_str):
                            continue
                        ini = datetime.datetime.strptime(start_str, "%H:%M").time()
                        fin = datetime.datetime.strptime(end_str, "%H:%M").time()

                        if ini < fin:
                            if ini <= ahora.time() <= fin:
                                activo = True
                        else:  # cruza medianoche
                            if ahora.time() >= ini or ahora.time() <= fin:
                                activo = True
                    except Exception as e:
                        print(f"[CFG] Horario inv√°lido: {h} ({e})")

            # Estado manda
            self.apagado = not activo
            cfg["encendido"] = activo
            cfg["modo"] = "horario"  # üî∏ asegurar que el modo viaja
            self._sync_encendido_to_backend(cfg)

        # Intervalo de env√≠o
        intervalo = cfg.get("intervalo_envio")
        if isinstance(intervalo, (int, float)) and intervalo > 0:
            self.interval = int(intervalo)

    def _poll_remote_config(self):
        while self.running and self.backend_url:
            try:
                self._ensure_device_id()
                if self._device_id is not None:
                    r = requests.get(f"{self.backend_url}/dispositivos/{self._device_id}", timeout=5)
                    if r.status_code == 200:
                        data = r.json()
                        cfg = data.get("configuracion") or {}
                        self._aplicar_config(cfg)
            except Exception as e:
                print(f"[CFG] Error leyendo configuraci√≥n remota: {e}")
            time.sleep(self.poll_config_interval)

    # ----------- API p√∫blica -----------
    def start(self):
        if self.running:
            return
        self.running = True
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()
        if self.backend_url:
            self._cfg_thread = threading.Thread(target=self._poll_remote_config, daemon=True)
            self._cfg_thread.start()

    def stop(self):
        self.running = False
        if self._thread:
            self._thread.join(timeout=1)

    def set_parametro(self, key, value):
        if key in self.parametros:
            mn = self.param_rules[key].get("min", float("-inf"))
            mx = self.param_rules[key].get("max", float("inf"))
            if isinstance(value, (int, float)) and (value < mn or value > mx):
                self.inyecciones[key] = True
            else:
                self.inyecciones[key] = False
            self.parametros[key] = value
            return True
        return False

    def set_parametros_bulk(self, new_params: dict):
        for k, v in new_params.items():
            if k in self.parametros:
                self.parametros[k] = v

    def apagar(self):
        self.apagado = True

    def encender(self):
        self.apagado = False

gen_qr.py----------------------------------------
# gen_qr.py
import qrcode
import json
import webbrowser
import os
import tempfile
import threading
import time

def generar_qr_reclamo(serial, templates_dict):
    def worker():
        prefix = serial[:4]  # usamos sufijo de 4 caracteres
        template = next(
            (tpl for tpl in templates_dict.values() if tpl.get("serial_prefix") == prefix),
            None
        )

        if not template:
            print(f"No se encontr√≥ template para prefijo {prefix}")
            return

        # Datos m√≠nimos para el reclamo
        data = {
            "serial_number": serial,
            "nombre": template.get("nombre", ""),
            "tipo": template.get("tipo", ""),
            "modelo": template.get("modelo", ""),
            "descripcion": template.get("descripcion", ""),
            "configuracion": template.get("configuracion", {})
        }

        # Crear QR en archivo temporal
        tmpdir = tempfile.gettempdir()
        img_path = os.path.join(tmpdir, f"qr_{serial}.png")
        qr = qrcode.make(json.dumps(data, ensure_ascii=False))
        qr.save(img_path)

        # Crear un HTML temporal que muestre el QR
        html_path = os.path.join(tmpdir, f"qr_{serial}.html")
        with open(html_path, "w", encoding="utf-8") as f:
            f.write(f"""
            <html>
            <head>
                <title>QR Dispositivo {serial}</title>
                <script>
                    // Eliminar archivos temporales cuando se cierre la ventana
                    window.onunload = async () => {{
                        try {{
                            fetch("file://{img_path}", {{ method: "DELETE" }});
                        }} catch(e) {{}}
                    }};
                </script>
            </head>
            <body style="text-align:center; margin-top:50px; font-family:Arial">
                <h2>Dispositivo: {serial}</h2>
                <img src="file://{img_path}" style="width:300px;height:300px;" />
                <p>Escanea este QR para reclamar el dispositivo.</p>
            </body>
            </html>
            """)

        print(f"‚úÖ QR generado en: {html_path}")
        webbrowser.open_new_tab(f"file://{html_path}")

        # Proceso de cleanup autom√°tico despu√©s de un rato
        def cleanup():
            time.sleep(60)  # espera 1 min aprox
            for path in [img_path, html_path]:
                try:
                    if os.path.exists(path):
                        os.remove(path)
                        print(f"üßπ Archivo eliminado: {path}")
                except Exception as e:
                    print(f"‚ö†Ô∏è No se pudo eliminar {path}: {e}")

        threading.Thread(target=cleanup, daemon=True).start()

    # Lanzamos en un hilo aparte para no bloquear
    threading.Thread(target=worker, daemon=True).start()

iot.txt----------------------------------------
Iot alchemy+++++++++++++++++++++++++++++++++++
Estructura de Archivos-----------------------
    |--cli.py
    |--config.json
    |--device.py
    |--gen_qr.py
    |--main.py
    |--manager.py
    |--templates_loader.py
    |--utils.py
    |--scripts/
        |--modificar.ps1
        |--reclamar.ps1
    |--templates/
        |--camara-seg_auto.json
        |--luces_auto.json
        |--persiana_auto.json
        |--puerta_auto.json
        |--regador_auto.json
        |--sensor_co2.json
        |--sensor_humo.json
        |--sensor_luz.json
        |--sensor_mov.json
        |--sensor_ruido.json
        |--sensor_smart-plug.json
        |--sensor_temp.json
        |--vent_auto.json

Contenido de Archivos-----------------------

cli.py----------------------------------------
# cli.py
import time
from templates_loader import cargar_plantillas
from manager import DevicesManager
from gen_qr import generar_qr_reclamo
from utils import reclamar_dispositivo, modificar_dispositivo, listar_dispositivos_backend

def show_menu():
    print("\n=== IoT Alchemy CLI ===")
    print("1) Listar plantillas")
    print("2) Crear dispositivo desde plantilla")
    print("3) Listar dispositivos activos")
    print("4) Iniciar simulaci√≥n de un dispositivo")
    print("5) Detener simulaci√≥n de un dispositivo")
    print("6) Modificar par√°metros de un dispositivo (en vivo-inyeccion de errores)")
    print("7) Iniciar simulaci√≥n de todos")
    print("8) Detener simulaci√≥n de todos")
    print("9) Generar QR de dispositivo (Abre Navegador)")
    print("++++++++++++++ Simulaciones de Front-End ++++++++++++++")
    print("10) Reclamar dispositivo v√≠a HTTP (PowerShell y cURL)")
    print("11) Modificar datos v√≠a HTTP (PowerShell y cURL)")
    print("0) Salir")

def iniciar_cli():
    templates = cargar_plantillas()
    manager = DevicesManager()

    while True:
        show_menu()
        opt = input("Opci√≥n: ").strip()
        if opt == "1":
            if not templates:
                print("No hay plantillas en /templates")
            else:
                print("Plantillas:")
                for name in templates:
                    print(" -", name)

        elif opt == "2":
            print("Seleccione plantilla:")
            keys = list(templates.keys())
            if not keys:
                print("No hay plantillas.")
                continue
            for i, k in enumerate(keys, 1):
                print(f"{i}) {k}")
            sel = input("N√∫mero: ").strip()
            try:
                idx = int(sel) - 1
                tpl = templates[keys[idx]]
            except Exception:
                print("Selecci√≥n inv√°lida.")
                continue

            serial_custom = input("Serial personalizado (ENTER para aleatorio): ").strip() or None
            cnt = input("¬øCu√°ntos dispositivos crear? (1): ").strip() or "1"
            try:
                cnt = int(cnt)
            except Exception:
                cnt = 1

            created = manager.create_from_template(tpl, count=cnt, serial_custom=serial_custom)
            for d in created:
                print(f"Creado: {d.serial} (intervalo: {d.interval}s)")

        elif opt == "3":
            devs = manager.list_devices()
            if not devs:
                print("No hay dispositivos creados.")
            else:
                for d in devs:
                    print(f"- {d.serial} | apagado:{d.apagado} | intervalo:{d.interval}s | params:{d.parametros}")

        elif opt == "4":
            s = input("Serial del dispositivo a iniciar: ").strip()
            d = manager.get(s)
            if not d:
                print("No encontrado.")
            else:
                d.start()
                print("Simulaci√≥n iniciada.")

        elif opt == "5":
            s = input("Serial del dispositivo a detener: ").strip()
            d = manager.get(s)
            if not d:
                print("No encontrado.")
            else:
                d.stop()
                print("Simulaci√≥n detenida.")

        elif opt == "6":
            s = input("Serial del dispositivo: ").strip()
            d = manager.get(s)
            if not d:
                print("No encontrado.")
            else:
                print("Par√°metros actuales:", d.parametros)
                key = input("Par√°metro a modificar: ").strip()
                if key not in d.parametros:
                    print("Par√°metro no existe.")
                else:
                    val = input("Nuevo valor: ").strip()
                    if val.lower() in ("true", "false"):
                        newv = val.lower() == "true"
                    else:
                        try:
                            if "." in val:
                                newv = float(val)
                            else:
                                newv = int(val)
                        except Exception:
                            newv = val
                    d.set_parametro(key, newv)
                    print("Par√°metro actualizado.")

        elif opt == "7":
            manager.start_all()
            print("Todas las simulaciones iniciadas.")

        elif opt == "8":
            manager.stop_all()
            print("Todas las simulaciones detenidas.")

        elif opt == "9":
            serial = input("Ingrese el serial del dispositivo: ").strip()
            generar_qr_reclamo(serial, templates)
        
        elif opt == "10":
            serial = input("Ingrese el serial del dispositivo: ")
            reclamar_dispositivo(serial, list(templates.values()))

        elif opt == "11":
            modificar_dispositivo()

        elif opt == "0":
            print("Saliendo...")
            manager.stop_all()
            break
        else:
            print("Opci√≥n inv√°lida.")
        time.sleep(0.2)
config.json----------------------------------------
{
  "mqtt_host": "localhost",
  "mqtt_port": 1883,
  "mqtt_topic_estado": "dispositivos/estado",
  "backend_url": "http://localhost:5000",
  "poll_config_interval": 3
}

device.py----------------------------------------
# device.py
import json
import os
import time
import threading
import random
import requests
import datetime
from paho.mqtt import publish
from utils import clamp

CONFIG_PATH = os.path.join(os.path.dirname(__file__), "config.json")
with open(CONFIG_PATH, "r", encoding="utf-8") as f:
    CONFIG = json.load(f)

# Mapa de equivalencias espa√±ol -> ingl√©s
DAY_MAP = {
    "lunes": "monday",
    "martes": "tuesday",
    "miercoles": "wednesday",
    "mi√©rcoles": "wednesday",
    "jueves": "thursday",
    "viernes": "friday",
    "sabado": "saturday",
    "s√°bado": "saturday",
    "domingo": "sunday",
}

class DeviceSimulator:
    """
    Publica SOLO por MQTT:
      { "serial_number", "estado", "parametros" }

    No env√≠a nada por HTTP. Opcionalmente LEE (GET) del backend
    para aplicar configuraciones:
      configuracion.intervalo_envio -> self.interval
      configuracion.encendido (True/False) -> self.apagado
      configuracion.modo ("manual"/"horario") -> define comportamiento
    """

    def __init__(
        self,
        serial,
        parametros_rules,
        mqtt_topic=None,
        interval=5,
        mqtt_host=None,
        backend_url=None,
        poll_config_interval=None
    ):
        self.serial = serial
        self.param_rules = parametros_rules or {}
        self.mqtt_topic = mqtt_topic or CONFIG.get("mqtt_topic_estado", "dispositivos/estado")
        self.mqtt_host = mqtt_host or CONFIG.get("mqtt_host", "localhost")
        self.backend_url = backend_url or CONFIG.get("backend_url")
        self.interval = max(1, int(interval))

        # Flags e hilos
        self.running = False
        self._thread = None
        self._cfg_thread = None

        # Estado/params
        self.apagado = False  # apagado=True -> estado="inactivo"
        self.parametros = {}
        for k, rule in self.param_rules.items():
            mn = rule.get("min", 0)
            mx = rule.get("max", 1)
            t = rule.get("tipo")
            if t in ("float", "double"):
                self.parametros[k] = round(random.uniform(mn, mx), 2)
            elif t == "int":
                self.parametros[k] = random.randint(int(mn), int(mx))
            elif t == "boolean":
                self.parametros[k] = random.choice([True, False])
            else:
                self.parametros[k] = rule.get("default")

        # Config remota (solo lectura)
        self.poll_config_interval = max(1, int(poll_config_interval or CONFIG.get("poll_config_interval", 3)))
        self._device_id = None  # cache para GET /dispositivos/<id>
        self.inyecciones = {k: False for k in self.param_rules}

        # √öltimo encendido sincronizado al backend
        self._last_encendido_sync = None

    # ----------- Simulaci√≥n -----------
    def _step(self):
        for k, rule in self.param_rules.items():
            if self.inyecciones.get(k, False):
                continue

            t = rule.get("tipo")
            if t in ("float", "double"):
                var = rule.get("variacion", (rule.get("max", 1) - rule.get("min", 0)) * 0.05)
                cur = float(self.parametros.get(k, 0))
                nuevo = clamp(cur + random.uniform(-var, var), rule.get("min", cur), rule.get("max", cur))
                self.parametros[k] = round(nuevo, 3)
            elif t == "int":
                var = rule.get("variacion", 1)
                cur = int(self.parametros.get(k, 0))
                nuevo = int(clamp(cur + random.randint(-var, var), rule.get("min", cur), rule.get("max", cur)))
                self.parametros[k] = nuevo
            elif t == "boolean":
                prob = rule.get("prob_flip", 0.01)
                if random.random() < prob:
                    self.parametros[k] = not bool(self.parametros.get(k, False))

    def _estado_str(self):
        return "inactivo" if self.apagado else "activo"

    def build_mqtt_payload(self):
        return {
            "serial_number": self.serial,
            "estado": self._estado_str(),
            "parametros": self.parametros
        }

    def publish_estado(self):
        payload = self.build_mqtt_payload()
        try:
            publish.single(self.mqtt_topic, json.dumps(payload), hostname=self.mqtt_host)
        except Exception as e:
            print("[MQTT ERROR]", e)

    def _run(self):
        while self.running:
            if not self.apagado:
                self._step()
                self.publish_estado()
            else:
                self.publish_estado()
            time.sleep(self.interval)

    # ----------- Config remota (solo lectura HTTP GET) -----------
    def _ensure_device_id(self):
        if not self.backend_url or self._device_id is not None:
            return
        try:
            r = requests.get(f"{self.backend_url}/dispositivos", timeout=5)
            if r.status_code == 200:
                lista = r.json()
                match = next((d for d in lista if d.get("serial_number") == self.serial), None)
                if match:
                    self._device_id = match["id"]
        except Exception as e:
            print(f"[CFG] Error buscando ID para {self.serial}: {e}")

    def _sync_encendido_to_backend(self, cfg):
        """Sincroniza encendido al backend solo si cambi√≥."""
        if not (self.backend_url and self._device_id is not None):
            return
        new_val = bool(cfg.get("encendido"))
        if self._last_encendido_sync is not None and self._last_encendido_sync == new_val:
            return  # no hay cambios
        try:
            resp = requests.put(
                f"{self.backend_url}/dispositivos/{self._device_id}",
                json={"configuracion": cfg, "encendido": new_val},
                timeout=5
            )
            if resp.status_code in (200, 204):
                self._last_encendido_sync = new_val
        except Exception as e:
            print(f"[CFG] Error sincronizando estado con backend: {e}")

    def _aplicar_config(self, cfg):
        # Si no hay modo ‚Üí dispositivo no reclamado todav√≠a
        modo = cfg.get("modo")
        if not modo:
            print(f"[CFG] {self.serial} a√∫n no reclamado, ignorando configuraci√≥n")
            return

        if modo == "manual":
            # En manual: encendido manda, estado escucha
            encendido = cfg.get("encendido", True)
            self.apagado = not bool(encendido)

        elif modo == "horario":
            # En horario: estado manda, encendido escucha
            ahora = datetime.datetime.now()
            dia_actual = ahora.strftime("%A").lower()

            activo = False
            for h in cfg.get("horarios", []):
                dias_cfg = [d.lower() for d in h.get("dias", ["todos"])]
                dias_norm = []
                for d in dias_cfg:
                    if d in DAY_MAP:
                        dias_norm.append(DAY_MAP[d])
                    else:
                        dias_norm.append(d)

                if "todos" in dias_norm or "all" in dias_norm or dia_actual in dias_norm:
                    try:
                        start_str = h.get("inicio") or h.get("start")
                        end_str   = h.get("fin")    or h.get("end")
                        if not (start_str and end_str):
                            continue
                        ini = datetime.datetime.strptime(start_str, "%H:%M").time()
                        fin = datetime.datetime.strptime(end_str, "%H:%M").time()

                        if ini < fin:
                            if ini <= ahora.time() <= fin:
                                activo = True
                        else:  # cruza medianoche
                            if ahora.time() >= ini or ahora.time() <= fin:
                                activo = True
                    except Exception as e:
                        print(f"[CFG] Horario inv√°lido: {h} ({e})")

            # Estado manda
            self.apagado = not activo
            cfg["encendido"] = activo
            self._sync_encendido_to_backend(cfg)

        # Intervalo de env√≠o
        intervalo = cfg.get("intervalo_envio")
        if isinstance(intervalo, (int, float)) and intervalo > 0:
            self.interval = int(intervalo)

    def _poll_remote_config(self):
        while self.running and self.backend_url:
            try:
                self._ensure_device_id()
                if self._device_id is not None:
                    r = requests.get(f"{self.backend_url}/dispositivos/{self._device_id}", timeout=5)
                    if r.status_code == 200:
                        data = r.json()
                        cfg = data.get("configuracion") or {}
                        self._aplicar_config(cfg)
            except Exception as e:
                print(f"[CFG] Error leyendo configuraci√≥n remota: {e}")
            time.sleep(self.poll_config_interval)

    # ----------- API p√∫blica -----------
    def start(self):
        if self.running:
            return
        self.running = True
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()
        if self.backend_url:
            self._cfg_thread = threading.Thread(target=self._poll_remote_config, daemon=True)
            self._cfg_thread.start()

    def stop(self):
        self.running = False
        if self._thread:
            self._thread.join(timeout=1)

    def set_parametro(self, key, value):
        if key in self.parametros:
            mn = self.param_rules[key].get("min", float("-inf"))
            mx = self.param_rules[key].get("max", float("inf"))
            if isinstance(value, (int, float)) and (value < mn or value > mx):
                self.inyecciones[key] = True
            else:
                self.inyecciones[key] = False
            self.parametros[key] = value
            return True
        return False

    def set_parametros_bulk(self, new_params: dict):
        for k, v in new_params.items():
            if k in self.parametros:
                self.parametros[k] = v

    def apagar(self):
        self.apagado = True

    def encender(self):
        self.apagado = False

gen_qr.py----------------------------------------
# gen_qr.py
import qrcode
import json
import webbrowser
import os
import tempfile
import threading
import time

def generar_qr_reclamo(serial, templates_dict):
    def worker():
        prefix = serial[:4]  # usamos sufijo de 4 caracteres
        template = next(
            (tpl for tpl in templates_dict.values() if tpl.get("serial_prefix") == prefix),
            None
        )

        if not template:
            print(f"No se encontr√≥ template para prefijo {prefix}")
            return

        # Datos m√≠nimos para el reclamo
        data = {
            "serial_number": serial,
            "nombre": template.get("nombre", ""),
            "tipo": template.get("tipo", ""),
            "modelo": template.get("modelo", ""),
            "descripcion": template.get("descripcion", ""),
            "configuracion": template.get("configuracion", {})
        }

        # Crear QR en archivo temporal
        tmpdir = tempfile.gettempdir()
        img_path = os.path.join(tmpdir, f"qr_{serial}.png")
        qr = qrcode.make(json.dumps(data, ensure_ascii=False))
        qr.save(img_path)

        # Crear un HTML temporal que muestre el QR
        html_path = os.path.join(tmpdir, f"qr_{serial}.html")
        with open(html_path, "w", encoding="utf-8") as f:
            f.write(f"""
            <html>
            <head>
                <title>QR Dispositivo {serial}</title>
                <script>
                    // Eliminar archivos temporales cuando se cierre la ventana
                    window.onunload = async () => {{
                        try {{
                            fetch("file://{img_path}", {{ method: "DELETE" }});
                        }} catch(e) {{}}
                    }};
                </script>
            </head>
            <body style="text-align:center; margin-top:50px; font-family:Arial">
                <h2>Dispositivo: {serial}</h2>
                <img src="file://{img_path}" style="width:300px;height:300px;" />
                <p>Escanea este QR para reclamar el dispositivo.</p>
            </body>
            </html>
            """)

        print(f"‚úÖ QR generado en: {html_path}")
        webbrowser.open_new_tab(f"file://{html_path}")

        # Proceso de cleanup autom√°tico despu√©s de un rato
        def cleanup():
            time.sleep(60)  # espera 1 min aprox
            for path in [img_path, html_path]:
                try:
                    if os.path.exists(path):
                        os.remove(path)
                        print(f"üßπ Archivo eliminado: {path}")
                except Exception as e:
                    print(f"‚ö†Ô∏è No se pudo eliminar {path}: {e}")

        threading.Thread(target=cleanup, daemon=True).start()

    # Lanzamos en un hilo aparte para no bloquear
    threading.Thread(target=worker, daemon=True).start()

main.py----------------------------------------
# main.py
from cli import iniciar_cli

if __name__ == "__main__":
    iniciar_cli()
manager.py----------------------------------------
import os
import json
from device import DeviceSimulator
from utils import generar_serial

CONFIG_PATH = os.path.join(os.path.dirname(__file__), "config.json")

def load_config():
    try:
        with open(CONFIG_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception as e:
        print(f"‚ö†Ô∏è No se pudo cargar config.json: {e}")
        return {}
    

class DevicesManager:
    def __init__(self):
        self.devices = {}  # serial -> DeviceSimulator
        self.config = load_config()

    def create_from_template(self, template, count=1, serial_custom=None):
        """
        Crea uno o varios dispositivos desde una plantilla.
        - Si serial_custom viene, solo crea 1 con ese serial exacto.
        - Si no, genera 'count' dispositivos con serial aleatorio.
        """
        created = []
        if serial_custom:
            seriales = [serial_custom]
        else:
            seriales = [generar_serial(template.get("serial_prefix", "DEV")) for _ in range(count)]

        for serial in seriales:
            params_rules = template.get("parametros", {}) or {}
            interval = int(template.get("configuracion", {}).get("intervalo_envio", 5))

            d = DeviceSimulator(
                serial=serial,
                parametros_rules=params_rules,
                mqtt_topic=self.config.get("mqtt_topic_estado", "dispositivos/estado"),
                interval=interval,
                mqtt_host=self.config.get("mqtt_host", "localhost"),
                backend_url=self.config.get("backend_url"),
                poll_config_interval=self.config.get("poll_config_interval", 3)
            )
            self.devices[serial] = d
            created.append(d)
        return created

    def list_devices(self):
        return list(self.devices.values())

    def get(self, serial):
        return self.devices.get(serial)

    def remove(self, serial):
        d = self.devices.pop(serial, None)
        if d:
            d.stop()
            return True
        return False

    def start_all(self):
        for d in self.devices.values():
            d.start()

    def stop_all(self):
        for d in self.devices.values():
            d.stop()

templates_loader.py----------------------------------------
# templates_loader.py
import os
import json

TEMPLATE_DIR = os.path.join(os.path.dirname(__file__), "templates")

def cargar_plantillas():
    plantillas = {}
    if not os.path.isdir(TEMPLATE_DIR):
        return plantillas
    for archivo in os.listdir(TEMPLATE_DIR):
        if archivo.endswith(".json"):
            nombre = archivo.replace(".json", "")
            ruta = os.path.join(TEMPLATE_DIR, archivo)
            with open(ruta, "r", encoding="utf-8") as f:
                plantillas[nombre] = json.load(f)
    return plantillas

utils.py----------------------------------------
# utils.py
import random
import string
import subprocess
import json
import os
import requests

SCRIPTS_DIR = os.path.join(os.path.dirname(__file__), "scripts")
CONFIG_PATH = os.path.join(os.path.dirname(__file__), "config.json")

## Cargar Config
def load_config():
    try:
        with open(CONFIG_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception as e:
        print(f"‚ö†Ô∏è No se pudo cargar config.json: {e}")
        return {}

def get_backend_url(path=""):
    config = load_config()
    base_url = config.get("backend_url", "http://localhost:5000").rstrip("/")
    if path:
        return f"{base_url}/{path.lstrip('/')}"
    return base_url

## Genera serial 
def generar_serial(prefix="DEV", length=8):
    rand_part = ''.join(random.choices(string.ascii_uppercase + string.digits, k=length))
    return f"{prefix}{rand_part}"

def clamp(v, mn, mx):
    return max(mn, min(mx, v))

def listar_dispositivos_backend():
    try:
        resp = requests.get(get_backend_url("dispositivos"))
        if resp.status_code == 200:
            return resp.json()
        else:
            print(f"‚ùå Error al listar dispositivos: {resp.status_code}")
            return []
    except Exception as e:
        print(f"‚ùå No se pudo conectar al backend: {e}")
        return []

#Utilizado opcion 10
def reclamar_dispositivo(serial, templates):
    prefix = serial[:4]
    template = next((t for t in templates if t.get("serial_prefix") == prefix), None)

    if not template:
        print(f"‚ùå No se encontr√≥ template para prefijo {prefix}")
        return

    # Construcci√≥n del payload
    payload = {
        "serial_number": serial,
        "nombre": template.get("nombre", ""),
        "tipo": template.get("tipo", ""),
        "modelo": template.get("modelo", ""),
        "descripcion": template.get("descripcion", ""),
        "configuracion": template.get("configuracion", {})
    }

    # Pasar parametros al script de PowerShell
    subprocess.run([
        "powershell", "-ExecutionPolicy", "Bypass", "-File", "scripts/reclamar.ps1",
        "-serial_number", payload["serial_number"],
        "-nombre", payload["nombre"],
        "-tipo", payload["tipo"],
        "-modelo", payload["modelo"],
        "-descripcion", payload["descripcion"],
        "-configuracion", json.dumps(payload["configuracion"])
    ])

# Utilizado opcion 11
def modificar_dispositivo():
    serial = input("Ingrese el serial del dispositivo a modificar: ").strip()
    dispositivos = listar_dispositivos_backend()

    if not dispositivos:
        print("‚ùå No hay dispositivos en el backend o no se pudo conectar.")
        return

    dispositivo = next((d for d in dispositivos if d.get("serial_number") == serial), None)
    if not dispositivo:
        print(f"‚ùå No se encontr√≥ un dispositivo con serial {serial}")
        return

    print(f"‚úÖ Dispositivo encontrado: {dispositivo.get('nombre', 'Sin nombre')} ({serial})")

    # Opciones editables
    opciones = {
        "1": "nombre",
        "2": "tipo",
        "3": "modelo",
        "4": "descripcion",
        "5": "configuracion"
    }

    print("¬øQu√© desea modificar?")
    for k, v in opciones.items():
        print(f"{k}) {v}")

    choice = input("Opci√≥n: ").strip()
    if choice not in opciones:
        print("‚ùå Opci√≥n inv√°lida")
        return

    campo = opciones[choice]

    # ---- Caso especial para configuraci√≥n ----
    if campo == "configuracion":
        print("Ingrese el JSON parcial con los cambios (ej: {\"modo\": \"horario\"}):")
        raw_valor = input("> ").strip()
        try:
            nuevo_valor = json.loads(raw_valor)
            if not isinstance(nuevo_valor, dict):
                print("‚ùå La configuraci√≥n debe ser un objeto JSON (ej: {\"encendido\": true})")
                return
        except json.JSONDecodeError as e:
            print(f"‚ùå JSON inv√°lido: {e}")
            return

        # Tomar la configuraci√≥n actual como base
        config_actual = dispositivo.get("configuracion", {}).copy()
        config_actual.update(nuevo_valor)

        # Normalizaci√≥n de modo
        modo = config_actual.get("modo")
        if modo == "horario" and "encendido" in config_actual:
            # Si es horario ‚Üí eliminamos encendido
            del config_actual["encendido"]
            print(" ‚úÖCambiado 'modo': 'horario';  ‚ùåEliminado 'encendido'")
        elif modo == "manual" and "horarios" in config_actual:
            # Si es manual ‚Üí eliminamos horarios
            del config_actual["horarios"]
            print(" ‚úÖCambiado 'modo': 'Manual' ‚ùåEliminado 'horarios'")

        payload = {"configuracion": config_actual}

    else:
        # Para nombre, tipo, modelo o descripcion
        nuevo_valor = input(f"Ingrese el nuevo valor para {campo}: ").strip()
        if not nuevo_valor:
            print("‚ùå El valor no puede estar vac√≠o.")
            return
        payload = {campo: nuevo_valor}

    print("üì§ Enviando actualizaci√≥n al backend...")

    try:
        subprocess.run([
            "powershell",
            "-ExecutionPolicy", "Bypass",
            "-File", os.path.join(SCRIPTS_DIR, "modificar.ps1"),
            "-id", str(dispositivo["id"]),
            "-payload", json.dumps(payload)
        ])
    except Exception as e:
        print(f"‚ùå Error al ejecutar script PowerShell: {e}")

scripts\modificar.ps1----------------------------------------
Ôªøparam(
    [string]$id,
    [string]$payload
)

# Cargar config.json
$configPath = Join-Path $PSScriptRoot "..\config.json"
$config = Get-Content $configPath | ConvertFrom-Json
$backendUrl = $config.backend_url.TrimEnd('/')

$url = "$backendUrl/dispositivos/$id/estado"

Write-Host "üîß Modificando dispositivo con ID: $id"
Write-Host "üåç Usando backend: $backendUrl"

try {
    $response = Invoke-RestMethod -Uri $url `
                                  -Method Put `
                                  -Body $payload `
                                  -ContentType "application/json; charset=utf-8"

    Write-Host "üì° Respuesta del servidor:"
    $response | ConvertTo-Json -Depth 5
}
catch {
    Write-Host "‚ùå Error al modificar dispositivo: $_"
}

scripts\reclamar.ps1----------------------------------------
Ôªøparam(
    [string]$serial_number,
    [string]$nombre,
    [string]$tipo,
    [string]$modelo,
    [string]$descripcion,
    [string]$configuracion
)

# Cargar config.json
$configPath = Join-Path $PSScriptRoot "..\config.json"
$config = Get-Content $configPath | ConvertFrom-Json
$backendUrl = $config.backend_url.TrimEnd('/')

# Construir el body como hashtable
$body = @{
    serial_number = $serial_number
    nombre        = $nombre
    tipo          = $tipo
    modelo        = $modelo
    descripcion   = $descripcion
    configuracion = (ConvertFrom-Json $configuracion)
}

# Convertir a JSON
$json = $body | ConvertTo-Json -Depth 5 -Compress

Write-Host "üì§ Enviando payload al backend..."
Write-Host $json
Write-Host "üåç Usando backend: $backendUrl"

# Ejecutar POST
try {
    $response = Invoke-RestMethod -Uri "$backendUrl/dispositivos/reclamar" `
                                  -Method POST `
                                  -Body $json `
                                  -ContentType 'application/json; charset=utf-8'

    Write-Host "‚úÖ Respuesta del backend:"
    $response | ConvertTo-Json -Depth 5
}
catch {
    Write-Host "‚ùå Error al enviar request: $_"
}

templates\camara-seg_auto.json----------------------------------------
{
  "serial_prefix": "CAM0",
  "nombre": "C√°mara de Seguridad",
  "tipo": "actuador",
  "modelo": "CAM-900",
  "descripcion": "C√°mara IP con transmisi√≥n de video y detecci√≥n de movimiento",
  "configuracion": {
    "intervalo_envio": 15,
    "encendido": true,
    "modo": "manual",
    "horarios": [
      {"dias": ["sabado","domingo"], "inicio": "00:00", "fin": "23:59"},
      {"dias": ["lunes","martes","miercoles","jueves","viernes"], "inicio": "20:00", "fin": "07:00"}
]

  },
  "parametros": {
    "stream_activo": {
      "tipo": "boolean",
      "prob_flip": 0.90
    },
    "alertas_movimiento": {
      "tipo": "boolean",
      "prob_flip": 0.1
    }
  }
}

templates\luces_auto.json----------------------------------------
{
  "serial_prefix": "LGT0",
  "nombre": "Luces Autom√°ticas",
  "tipo": "actuador",
  "modelo": "LGT-300",
  "descripcion": "Sistema de iluminaci√≥n con encendido y apagado autom√°tico",
  "configuracion": {
    "intervalo_envio": 10,
    "encendido": true,
    "modo": "manual",
    "horarios": [
      { "dias": ["todos"], "inicio": "18:00", "fin": "06:00" }
    ]
  },
  "parametros": {}
}

templates\persiana_auto.json----------------------------------------
{
  "serial_prefix": "SHD0",
  "nombre": "Persiana Inteligente",
  "tipo": "actuador",
  "modelo": "SHD-400",
  "descripcion": "Control de apertura y cierre de persianas",
  "configuracion": {
    "intervalo_envio": 8,
    "encendido": true,
    "modo": "manual"
  },
  "parametros": {
  }
}

templates\puerta_auto.json----------------------------------------
{
  "serial_prefix": "DRL0",
  "nombre": "Puerta Inteligente",
  "tipo": "actuador",
  "modelo": "DR-200",
  "descripcion": "Puerta con cerradura inteligente y control remoto",
  "configuracion": {
    "intervalo_envio": 12,
    "encendido": true,
    "modo": "manual"
  },
  "parametros": {

  }
}

templates\regador_auto.json----------------------------------------
{
  "serial_prefix": "RGD0",
  "nombre": "Regador Autom√°tico",
  "tipo": "actuador",
  "modelo": "RG-500",
  "descripcion": "Sistema autom√°tico de riego programado",
  "configuracion": {
    "intervalo_envio": 20,
    "encendido": false,
    "modo": "manual",
    "horarios": [
      { "dias": ["lunes","miercoles","viernes"], "inicio": "06:00", "fin": "06:15" }
    ]
  },
  "parametros": {}
}

templates\sensor_co2.json----------------------------------------
{
  "serial_prefix": "CO20",
  "nombre": "Sensor de CO‚ÇÇ",
  "tipo": "sensor",
  "modelo": "C2-300",
  "descripcion": "Medidor de concentraci√≥n de di√≥xido de carbono en ppm",
  "configuracion": {
    "intervalo_envio": 12,
    "encendido": true,
    "modo": "manual"

  },
  "parametros": {
    "co2_ppm": {
      "tipo": "int",
      "min": 0,
      "max": 800,
      "variacion": 50
    }
  }
}

templates\sensor_humo.json----------------------------------------
{
  "serial_prefix": "SMK0",
  "nombre": "Detector de Humo",
  "tipo": "sensor",
  "modelo": "SM-150",
  "descripcion": "Alarma contra incendios",
  "configuracion": {
    "intervalo_envio": 20,
    "encendido": true,
    "modo": "manual"
  },
  "parametros": {
    "humo_detectado": {
      "tipo": "boolean",
      "prob_flip": 0.002
    }
  }
}

templates\sensor_luz.json----------------------------------------
{
  "serial_prefix": "LUX0",
  "nombre": "Sensor de Luz",
  "tipo": "sensor",
  "modelo": "LX-500",
  "descripcion": "Sensor de intensidad luminosa en lux",
  "configuracion": {
    "intervalo_envio": 8,
    "encendido": true,
    "modo": "manual"

  },
  "parametros": {
    "luz_lux": {
      "tipo": "float",
      "min": 0.0,
      "max": 500.0,
      "variacion": 20.0
    }
  }
}

templates\sensor_mov.json----------------------------------------
{
  "serial_prefix": "MOV0",
  "nombre": "Sensor de Movimiento",
  "tipo": "sensor",
  "modelo": "MOV-200",
  "descripcion": "Sensor binario de movimiento",
  "configuracion": {
    "intervalo_envio": 10,
    "encendido": true,
    "modo": "manual",
    "horarios": [
    {"dias": ["todos"], "inicio": "21:25", "fin": "21:30"}
  ]
  },
  "parametros": {
    "movimiento": {
      "tipo": "boolean",
      "prob_flip": 0.01
    }
  }
}

templates\sensor_ruido.json----------------------------------------
{
  "serial_prefix": "SND0",
  "nombre": "Sensor de Ruido",
  "tipo": "sensor",
  "modelo": "SN-200",
  "descripcion": "Medidor de niveles sonoros en decibeles",
  "configuracion": {
    "intervalo_envio": 7,
    "encendido": true,
    "modo": "manual"

  },
  "parametros": {
    "db": {
      "tipo": "float",
      "min": 30.0,
      "max": 80.0,
      "variacion": 5.0
    }
  }
}

templates\sensor_smart-plug.json----------------------------------------
{
  "serial_prefix": "PLG0",
  "nombre": "Smart Plug",
  "tipo": "actuador",
  "modelo": "SP-100",
  "descripcion": "Medidor de consumo electrico",
  "configuracion": {
    "intervalo_envio": 6,
    "encendido": true,
    "modo": "manual"

  },
  "parametros": {
    "consumo_w": {
      "tipo": "float",
      "min": 0.0,
      "max": 2000.0,
      "variacion": 50.0
    }
  }
}

templates\sensor_temp.json----------------------------------------
{
  "serial_prefix": "TMP0",
  "nombre": "Sensor de Temperatura Generico",
  "tipo": "sensor",
  "modelo": "ST-1000",
  "descripcion": "Sensor de temperatura",
  "configuracion": {
    "intervalo_envio": 5,
    "encendido": true,
    "modo": "manual"

  },
  "parametros": {
    "temperatura": {
      "tipo": "float",
      "min": 20.0,
      "max": 30.0,
      "variacion": 0.3
    },
    "humedad": {
      "tipo": "int",
      "min": 35,
      "max": 65,
      "variacion": 2
    }
  }
}

templates\vent_auto.json----------------------------------------
{
  "serial_prefix": "FAN0",
  "nombre": "Ventilador Inteligente",
  "tipo": "actuador",
  "modelo": "FAN-300",
  "descripcion": "Ventilador con control de velocidad inteligente",
  "configuracion": {
    "intervalo_envio": 10,
    "encendido": false,
    "modo": "manual"
  },
  "parametros": {
    "velocidad": {
      "tipo": "int",
      "min": 0,
      "max": 3,
      "variacion": 1
    }
  }
}


main.py----------------------------------------
# main.py
from cli import iniciar_cli

if __name__ == "__main__":
    iniciar_cli()
manager.py----------------------------------------
import os
import json
from device import DeviceSimulator
from utils import generar_serial

CONFIG_PATH = os.path.join(os.path.dirname(__file__), "config.json")

def load_config():
    try:
        with open(CONFIG_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception as e:
        print(f"‚ö†Ô∏è No se pudo cargar config.json: {e}")
        return {}
    

class DevicesManager:
    def __init__(self):
        self.devices = {}  # serial -> DeviceSimulator
        self.config = load_config()

    def create_from_template(self, template, count=1, serial_custom=None):
        """
        Crea uno o varios dispositivos desde una plantilla.
        - Si serial_custom viene, solo crea 1 con ese serial exacto.
        - Si no, genera 'count' dispositivos con serial aleatorio.
        """
        created = []
        if serial_custom:
            seriales = [serial_custom]
        else:
            seriales = [generar_serial(template.get("serial_prefix", "DEV")) for _ in range(count)]

        for serial in seriales:
            params_rules = template.get("parametros", {}) or {}
            interval = int(template.get("configuracion", {}).get("intervalo_envio", 5))

            d = DeviceSimulator(
                serial=serial,
                parametros_rules=params_rules,
                mqtt_topic=self.config.get("mqtt_topic_estado", "dispositivos/estado"),
                interval=interval,
                mqtt_host=self.config.get("mqtt_host", "localhost"),
                backend_url=self.config.get("backend_url"),
                poll_config_interval=self.config.get("poll_config_interval", 3)
            )
            self.devices[serial] = d
            created.append(d)
        return created

    def list_devices(self):
        return list(self.devices.values())

    def get(self, serial):
        return self.devices.get(serial)

    def remove(self, serial):
        d = self.devices.pop(serial, None)
        if d:
            d.stop()
            return True
        return False

    def start_all(self):
        for d in self.devices.values():
            d.start()

    def stop_all(self):
        for d in self.devices.values():
            d.stop()

templates_loader.py----------------------------------------
# templates_loader.py
import os
import json

TEMPLATE_DIR = os.path.join(os.path.dirname(__file__), "templates")

def cargar_plantillas():
    plantillas = {}
    if not os.path.isdir(TEMPLATE_DIR):
        return plantillas
    for archivo in os.listdir(TEMPLATE_DIR):
        if archivo.endswith(".json"):
            nombre = archivo.replace(".json", "")
            ruta = os.path.join(TEMPLATE_DIR, archivo)
            with open(ruta, "r", encoding="utf-8") as f:
                plantillas[nombre] = json.load(f)
    return plantillas

utils.py----------------------------------------
# utils.py
import random
import string
import subprocess
import json
import os
import requests

SCRIPTS_DIR = os.path.join(os.path.dirname(__file__), "scripts")
CONFIG_PATH = os.path.join(os.path.dirname(__file__), "config.json")

## Cargar Config
def load_config():
    try:
        with open(CONFIG_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception as e:
        print(f"‚ö†Ô∏è No se pudo cargar config.json: {e}")
        return {}

def get_backend_url(path=""):
    config = load_config()
    base_url = config.get("backend_url", "http://localhost:5000").rstrip("/")
    if path:
        return f"{base_url}/{path.lstrip('/')}"
    return base_url

## Genera serial 
def generar_serial(prefix="DEV", length=8):
    rand_part = ''.join(random.choices(string.ascii_uppercase + string.digits, k=length))
    return f"{prefix}{rand_part}"

def clamp(v, mn, mx):
    return max(mn, min(mx, v))

def listar_dispositivos_backend():
    try:
        resp = requests.get(get_backend_url("dispositivos"))
        if resp.status_code == 200:
            return resp.json()
        else:
            print(f"‚ùå Error al listar dispositivos: {resp.status_code}")
            return []
    except Exception as e:
        print(f"‚ùå No se pudo conectar al backend: {e}")
        return []

#Utilizado opcion 10
def reclamar_dispositivo(serial, templates):
    prefix = serial[:4]
    template = next((t for t in templates if t.get("serial_prefix") == prefix), None)

    if not template:
        print(f"‚ùå No se encontr√≥ template para prefijo {prefix}")
        return

    # Construcci√≥n del payload
    payload = {
        "serial_number": serial,
        "nombre": template.get("nombre", ""),
        "tipo": template.get("tipo", ""),
        "modelo": template.get("modelo", ""),
        "descripcion": template.get("descripcion", ""),
        "configuracion": template.get("configuracion", {})
    }

    # Pasar parametros al script de PowerShell
    subprocess.run([
        "powershell", "-ExecutionPolicy", "Bypass", "-File", "scripts/reclamar.ps1",
        "-serial_number", payload["serial_number"],
        "-nombre", payload["nombre"],
        "-tipo", payload["tipo"],
        "-modelo", payload["modelo"],
        "-descripcion", payload["descripcion"],
        "-configuracion", json.dumps(payload["configuracion"])
    ])

# Utilizado opcion 11
def modificar_dispositivo():
    serial = input("Ingrese el serial del dispositivo a modificar: ").strip()
    dispositivos = listar_dispositivos_backend()

    if not dispositivos:
        print("‚ùå No hay dispositivos en el backend o no se pudo conectar.")
        return

    dispositivo = next((d for d in dispositivos if d.get("serial_number") == serial), None)
    if not dispositivo:
        print(f"‚ùå No se encontr√≥ un dispositivo con serial {serial}")
        return

    print(f"‚úÖ Dispositivo encontrado: {dispositivo.get('nombre', 'Sin nombre')} ({serial})")

    # Opciones editables
    opciones = {
        "1": "nombre",
        "2": "tipo",
        "3": "modelo",
        "4": "descripcion",
        "5": "configuracion"
    }

    print("¬øQu√© desea modificar?")
    for k, v in opciones.items():
        print(f"{k}) {v}")

    choice = input("Opci√≥n: ").strip()
    if choice not in opciones:
        print("‚ùå Opci√≥n inv√°lida")
        return

    campo = opciones[choice]

    # ---- Caso especial para configuraci√≥n ----
    if campo == "configuracion":
        print("Ingrese el JSON parcial con los cambios (ej: {\"modo\": \"horario\"}):")
        raw_valor = input("> ").strip()
        try:
            nuevo_valor = json.loads(raw_valor)
            if not isinstance(nuevo_valor, dict):
                print("‚ùå La configuraci√≥n debe ser un objeto JSON (ej: {\"encendido\": true})")
                return
        except json.JSONDecodeError as e:
            print(f"‚ùå JSON inv√°lido: {e}")
            return

        # Tomar la configuraci√≥n actual como base
        config_actual = dispositivo.get("configuracion", {}).copy()
        config_actual.update(nuevo_valor)

        # Normalizaci√≥n de modo
        modo = config_actual.get("modo")
        if modo == "horario" and "encendido" in config_actual:
            print(" ‚úÖCambiado 'modo': 'horario'")
        elif modo == "manual" and "horarios" in config_actual:
            print(" ‚úÖCambiado 'modo': 'Manual'")

        payload = {"configuracion": config_actual}

    else:
        # Para nombre, tipo, modelo o descripcion
        nuevo_valor = input(f"Ingrese el nuevo valor para {campo}: ").strip()
        if not nuevo_valor:
            print("‚ùå El valor no puede estar vac√≠o.")
            return
        payload = {campo: nuevo_valor}

    # ... despu√©s de construir 'payload' (dict) ...
    # ... tras construir 'payload' (dict) ...
    print("üì§ Enviando actualizaci√≥n al backend...")

    try:
        subprocess.run([
            "powershell",
            "-ExecutionPolicy", "Bypass",
            "-File", os.path.join(SCRIPTS_DIR, "modificar.ps1"),
            "-id", str(dispositivo["id"]),
            "-payload", json.dumps(payload)
        ])
    except Exception as e:
        print(f"‚ùå Error al ejecutar script PowerShell: {e}")



scripts\modificar.ps1----------------------------------------
Ôªøparam(
    [Parameter(Mandatory=$true)][string]$id,
    [Parameter(Mandatory=$true)][string]$payload
)

# Cargar config.json (igual que reclamar.ps1)
$scriptDir  = Split-Path -Parent $MyInvocation.MyCommand.Path
$configPath = Join-Path $scriptDir "..\config.json"
$config     = Get-Content $configPath | ConvertFrom-Json
$backendUrl = $config.backend_url.TrimEnd('/')

# Endpoint √∫nico (parciales / mode-aware)
$url = "$backendUrl/dispositivos/$id"

Write-Host "üîß Modificando dispositivo con ID: $id"
Write-Host "üåç Endpoint: $url"
Write-Host "üì§ Payload:"
Write-Host $payload

try {
    $response = Invoke-RestMethod -Uri $url `
                                  -Method Put `
                                  -Body $payload `
                                  -ContentType "application/json; charset=utf-8"
    Write-Host "‚úÖ Respuesta del servidor:"
    $response | ConvertTo-Json -Depth 10
}
catch {
    Write-Host "‚ùå Error al modificar dispositivo: $_"
}

scripts\reclamar.ps1----------------------------------------
Ôªøparam(
    [string]$serial_number,
    [string]$nombre,
    [string]$tipo,
    [string]$modelo,
    [string]$descripcion,
    [string]$configuracion
)

# Cargar config.json
$configPath = Join-Path $PSScriptRoot "..\config.json"
$config = Get-Content $configPath | ConvertFrom-Json
$backendUrl = $config.backend_url.TrimEnd('/')

# Construir el body como hashtable
$body = @{
    serial_number = $serial_number
    nombre        = $nombre
    tipo          = $tipo
    modelo        = $modelo
    descripcion   = $descripcion
    configuracion = (ConvertFrom-Json $configuracion)
}

# Convertir a JSON
$json = $body | ConvertTo-Json -Depth 5 -Compress

Write-Host "üì§ Enviando payload al backend..."
Write-Host $json
Write-Host "üåç Usando backend: $backendUrl"

# Ejecutar POST
try {
    $response = Invoke-RestMethod -Uri "$backendUrl/dispositivos/reclamar" `
                                  -Method POST `
                                  -Body $json `
                                  -ContentType 'application/json; charset=utf-8'

    Write-Host "‚úÖ Respuesta del backend:"
    $response | ConvertTo-Json -Depth 5
}
catch {
    Write-Host "‚ùå Error al enviar request: $_"
}

templates\camara-seg_auto.json----------------------------------------
{
  "serial_prefix": "CAM0",
  "nombre": "C√°mara de Seguridad",
  "tipo": "actuador",
  "modelo": "CAM-900",
  "descripcion": "C√°mara IP con transmisi√≥n de video y detecci√≥n de movimiento",
  "configuracion": {
    "intervalo_envio": 15,
    "encendido": true,
    "modo": "manual",
    "horarios": [
      {"dias": ["sabado","domingo"], "inicio": "00:00", "fin": "23:59"},
      {"dias": ["lunes","martes","miercoles","jueves","viernes"], "inicio": "20:00", "fin": "07:00"}
]

  },
  "parametros": {
    "stream_activo": {
      "tipo": "boolean",
      "prob_flip": 0.90
    },
    "alertas_movimiento": {
      "tipo": "boolean",
      "prob_flip": 0.1
    }
  }
}

templates\luces_auto.json----------------------------------------
{
  "serial_prefix": "LGT0",
  "nombre": "Luces Autom√°ticas",
  "tipo": "actuador",
  "modelo": "LGT-300",
  "descripcion": "Sistema de iluminaci√≥n con encendido y apagado autom√°tico",
  "configuracion": {
    "intervalo_envio": 10,
    "encendido": true,
    "modo": "manual",
    "horarios": [
      { "dias": ["todos"], "inicio": "18:00", "fin": "06:00" }
    ]
  },
  "parametros": {}
}

templates\persiana_auto.json----------------------------------------
{
  "serial_prefix": "SHD0",
  "nombre": "Persiana Inteligente",
  "tipo": "actuador",
  "modelo": "SHD-400",
  "descripcion": "Control de apertura y cierre de persianas",
  "configuracion": {
    "intervalo_envio": 8,
    "encendido": true,
    "modo": "manual"
  },
  "parametros": {
  }
}

templates\puerta_auto.json----------------------------------------
{
  "serial_prefix": "DRL0",
  "nombre": "Puerta Inteligente",
  "tipo": "actuador",
  "modelo": "DR-200",
  "descripcion": "Puerta con cerradura inteligente y control remoto",
  "configuracion": {
    "intervalo_envio": 12,
    "encendido": true,
    "modo": "manual"
  },
  "parametros": {

  }
}

templates\regador_auto.json----------------------------------------
{
  "serial_prefix": "RGD0",
  "nombre": "Regador Autom√°tico",
  "tipo": "actuador",
  "modelo": "RG-500",
  "descripcion": "Sistema autom√°tico de riego programado",
  "configuracion": {
    "intervalo_envio": 20,
    "encendido": false,
    "modo": "manual",
    "horarios": [
      { "dias": ["lunes","miercoles","viernes"], "inicio": "06:00", "fin": "06:15" }
    ]
  },
  "parametros": {}
}

templates\sensor_co2.json----------------------------------------
{
  "serial_prefix": "CO20",
  "nombre": "Sensor de CO‚ÇÇ",
  "tipo": "sensor",
  "modelo": "C2-300",
  "descripcion": "Medidor de concentraci√≥n de di√≥xido de carbono en ppm",
  "configuracion": {
    "intervalo_envio": 12,
    "encendido": true,
    "modo": "manual"

  },
  "parametros": {
    "co2_ppm": {
      "tipo": "int",
      "min": 0,
      "max": 800,
      "variacion": 50
    }
  }
}

templates\sensor_humo.json----------------------------------------
{
  "serial_prefix": "SMK0",
  "nombre": "Detector de Humo",
  "tipo": "sensor",
  "modelo": "SM-150",
  "descripcion": "Alarma contra incendios",
  "configuracion": {
    "intervalo_envio": 20,
    "encendido": true,
    "modo": "manual"
  },
  "parametros": {
    "humo_detectado": {
      "tipo": "boolean",
      "prob_flip": 0.002
    }
  }
}

templates\sensor_luz.json----------------------------------------
{
  "serial_prefix": "LUX0",
  "nombre": "Sensor de Luz",
  "tipo": "sensor",
  "modelo": "LX-500",
  "descripcion": "Sensor de intensidad luminosa en lux",
  "configuracion": {
    "intervalo_envio": 8,
    "encendido": true,
    "modo": "manual"

  },
  "parametros": {
    "luz_lux": {
      "tipo": "float",
      "min": 0.0,
      "max": 500.0,
      "variacion": 20.0
    }
  }
}

templates\sensor_mov.json----------------------------------------
{
  "serial_prefix": "MOV0",
  "nombre": "Sensor de Movimiento",
  "tipo": "sensor",
  "modelo": "MOV-200",
  "descripcion": "Sensor binario de movimiento",
  "configuracion": {
    "intervalo_envio": 10,
    "encendido": true,
    "modo": "manual",
    "horarios": [
    {"dias": ["todos"], "inicio": "21:25", "fin": "21:30"}
  ]
  },
  "parametros": {
    "movimiento": {
      "tipo": "boolean",
      "prob_flip": 0.01
    }
  }
}

templates\sensor_ruido.json----------------------------------------
{
  "serial_prefix": "SND0",
  "nombre": "Sensor de Ruido",
  "tipo": "sensor",
  "modelo": "SN-200",
  "descripcion": "Medidor de niveles sonoros en decibeles",
  "configuracion": {
    "intervalo_envio": 7,
    "encendido": true,
    "modo": "manual"

  },
  "parametros": {
    "db": {
      "tipo": "float",
      "min": 30.0,
      "max": 80.0,
      "variacion": 5.0
    }
  }
}

templates\sensor_smart-plug.json----------------------------------------
{
  "serial_prefix": "PLG0",
  "nombre": "Smart Plug",
  "tipo": "actuador",
  "modelo": "SP-100",
  "descripcion": "Medidor de consumo electrico",
  "configuracion": {
    "intervalo_envio": 6,
    "encendido": true,
    "modo": "manual"

  },
  "parametros": {
    "consumo_w": {
      "tipo": "float",
      "min": 0.0,
      "max": 2000.0,
      "variacion": 50.0
    }
  }
}

templates\sensor_temp.json----------------------------------------
{
  "serial_prefix": "TMP0",
  "nombre": "Sensor de Temperatura Generico",
  "tipo": "sensor",
  "modelo": "ST-1000",
  "descripcion": "Sensor de temperatura",
  "configuracion": {
    "intervalo_envio": 5,
    "encendido": true,
    "modo": "manual"

  },
  "parametros": {
    "temperatura": {
      "tipo": "float",
      "min": 20.0,
      "max": 30.0,
      "variacion": 0.3
    },
    "humedad": {
      "tipo": "int",
      "min": 35,
      "max": 65,
      "variacion": 2
    }
  }
}

templates\vent_auto.json----------------------------------------
{
  "serial_prefix": "FAN0",
  "nombre": "Ventilador Inteligente",
  "tipo": "actuador",
  "modelo": "FAN-300",
  "descripcion": "Ventilador con control de velocidad inteligente",
  "configuracion": {
    "intervalo_envio": 10,
    "encendido": false,
    "modo": "manual"
  },
  "parametros": {
    "velocidad": {
      "tipo": "int",
      "min": 0,
      "max": 3,
      "variacion": 1
    }
  }
}

